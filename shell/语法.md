* shell只有一种数据类型，就是字符串。特殊字符需要进行转义才能实现功能
* echo
    * 若要换将输出，则输入 "" 双引号即可。原理就是双引号中反斜杠会保留特殊符号的功能
        * 还有一种 here 文档，可以指定输入多行字符串的方法。即 << token ... token
    * -n，取消末尾的回车符
    * -e，转义特殊字符，如输入字符中的换行符等
    * 使用空格区分不同的参数
    * echo $date 不会输出任何信息，因为 $ 是一个特殊字符，可以通过加斜杠的方式进行转义 echo \$date，因为反斜杠本身也是特殊字符，所以双反斜杠才可以输出反斜杠
* 字符串搜索和替换
    * 头部匹配
        * ${variable#pattern}
            * 匹配变量的开头，匹配成功时删除匹配的部分（非贪婪），然后返回剩下的部分
            * `myPath=/home/cam/book/long.file.name`
                * `echo ${myPath#/*/}` 得到 cam/book/long.file.name
                * `echo ${myPath##/*/}` 得到 long.file.name
                * `echo ${path##*/}` 得到 long.file.name
        * ${variable##pattern}
            * 匹配成功时，删除最长匹配（贪婪匹配），然后返回剩余部分
    * 尾部匹配
        * ${variable%pattern}
            * `myPath=/home/cam/book/long.file.name`
                * `echo ${myPath%.*}` 得到 /home/cam/book/long.file
                * `echo ${myPath%%.*}` 得到 /home/cam/book/long
        * ${variable%%pattern}
* export
    * 子shell默认是读取不到父shell定义的变量，为了把变量传递给子shell，可以使用export命令，这样输出的变量，对于子shell来说就是环境变量
* let 关键字
    * 声明变量时可以直接执行算术表达式
* && 与
* || 或
* 接收到的指令通过空格进行拆分，遇到特殊的指令则进行对应的拓展
    * \
        * 换行符，表示当前行命令结束，会进行对应的换行
    * ~
        * 波浪线会拓展成用户的主目录
        * `~/dir` 拓展成当前用户主目录的某个子目录
        * `~cza` 拓展成用户 cza 的主目录
        * `~+` 会展示当前所在的目录，等同于 pwd 指令
    * ?
        * 表示单个字符的匹配，那么 ?? 也就是双字符的任意匹配，一般用户文件拓展名的查询上
    * *
        * 表示任意个字符的匹配
    * []
        * 指定方括号中的任意一个匹配
        * 支持 [start-end]，即 [0-9a-zA-Z] 的正则方式进行匹配
    * {}
        * 括号内不支持空格
        * 表示匹配内部所有的内容，即 {a,b,c} 表示匹配对应的abc。他会拓展成所有给定的值，而不会检查目标是否存在或者有其他异常
        * 同样支持 {start..end} 的形式
        * 一般用来和python中的range函数对比， `for i in {1..10}; do echo $i; done; `
        * 使用两次可以指定对应的步长， `for i in {1..10..2}; do echo $i; done;`
    * $
        * 美元符号视为变量值
        * $variable || ${variable}
            * $a_name，这种会将整体都视为变量
            * ${a}_name，这种会先获取a变量，然后进行后续的操作
                * ${name:-cza} 若name不存在或为空，则返回cza
                * ${name:=cza} 若name不存在或为空，则设置为cza，然后返回cza
                * ${name:+cza} 若name存在且不为空，则返回cza，否则返回空值。仅仅是测试变量是否存在，不会对原变量做处理
                * ${name:?cza} 若name不存在或为空，则中断执行脚本，目的是为了防止变量未定义，如：`${count:?"undefined!"}`
                    * `${1:?"filename missing. exit now."}` 表示验证输入的第一个参数是否存在，不存在则退出 
        * ${!*} 支持使用正则来返回匹配的变量名 ${!STRING*} || ${!STRING@}，比如使用 ${!S*} 即可返回以S开头的相关变量
        * $() 可以拓展另一个命令的运行结果，即该命令的所有输出值都会作为返回值
        * $(()) 可以拓展相关的计算，即 $((2 + 2)) 
        * ${#} 可以获取字符串的长度
    * 引号
        * 单引号
            * 特殊字符放在单引号中，则会变成普通字符。若单引号内部仍要使用单引号，则需要在首位加上 $ 符号，即 echo $'h\'h'
        * 双引号
            * 大部分特殊符号会失去作用，除了三个
                * $ 美元符号
                * ` 反引号
                * \ 反斜杠。可以直接使用反斜杠进行转义特殊字符
    * $?
        * 表示上一个命令的退出码
        * `cd /; if [ $? == "0" ]; then rm -rf *; else echo cd error; fi;`，可以更简洁 `cd / && rm -rf *`，`cd / || exit 1`
    * $$
        * 表示当前shell的进程ID
    * $_
        * 表示上一个命令的最后一个参数
    * $!
        * 表示最近一个后台执行的异步命令的进程ID
    * $0
        * 表示为当前shell的名称，或者脚本的名称
    * $#
        * 参数的总数
    * $-
        * 表示当前shell的启动参数
    * $@
        * 全部的参数，参数之间使用空格分隔
        * `for i in $@; do echo $i; done;`
    * $(())
        * 算术表达式，会自动忽略内部的空格，在内部引用变量不需要加上美元符号，加上了也不会报错。但是如果使用字符串，那么会默认为变量名，当不存在此变量名时会将其置为空值
        * ((foo = 5 + 5)); echo $foo; 可以执行这类赋值运算
    * shift
        * 改变脚本参数，每次执行都会移除脚本的第一个参数，导致后面的参数会前移
* 语法
    * `#!/bin/sh` || `#!/bin/bash` || `#!/usr/bin/env bash`，一般使用最后一种，调用了env命令，返回bash可执行的文件位置
    * alias
        * 用于创建别名
        * `alias today='date +"%A, %B %-d, %Y"'`
    * read
        * 与用户进行交互，可以存储用户的输入
    * 数组
        * array[0]=1;array[1]=2; 读取数组的所有成员，使用 `echo ${array[@]}`



